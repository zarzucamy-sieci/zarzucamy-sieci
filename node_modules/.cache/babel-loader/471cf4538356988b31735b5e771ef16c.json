{"ast":null,"code":"\"use strict\";\n\nvar objectAssign = require('object-assign');\n/* eslint-disable max-depth, complexity */\n\n\nfunction nestLists(blocks) {\n  var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'html';\n  var tree = [];\n  var currentList;\n\n  for (var i = 0; i < blocks.length; i++) {\n    var block = blocks[i];\n\n    if (!isListBlock(block)) {\n      tree.push(block);\n      currentList = null;\n      continue;\n    } // Start of a new list?\n\n\n    if (!currentList) {\n      currentList = listFromBlock(block);\n      tree.push(currentList);\n      continue;\n    } // New list item within same list?\n\n\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block);\n      continue;\n    } // Different list props, are we going deeper?\n\n\n    if (block.level > currentList.level) {\n      var newList = listFromBlock(block);\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // We actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n        // Clone the last child while adding our new list as the last child of it\n        var lastListItem = lastChild(currentList);\n        var newLastChild = objectAssign({}, lastListItem, {\n          children: lastListItem.children.concat(newList)\n        }); // Swap the last child\n\n        currentList.children[currentList.children.length - 1] = newLastChild;\n      } else {\n        currentList.children.push(newList);\n      } // Set the newly created, deeper list as the current\n\n\n      currentList = newList;\n      continue;\n    } // Different list props, are we going back up the tree?\n\n\n    if (block.level < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      var match = findListMatching(tree[tree.length - 1], block);\n\n      if (match) {\n        currentList = match;\n        currentList.children.push(block);\n        continue;\n      } // Similar parent can't be found, assume new list\n\n\n      currentList = listFromBlock(block);\n      tree.push(currentList);\n      continue;\n    } // Different list props, different list style?\n\n\n    if (block.listItem !== currentList.listItem) {\n      var _match = findListMatching(tree[tree.length - 1], {\n        level: block.level\n      });\n\n      if (_match && _match.listItem === block.listItem) {\n        currentList = _match;\n        currentList.children.push(block);\n        continue;\n      } else {\n        currentList = listFromBlock(block);\n        tree.push(currentList);\n        continue;\n      }\n    } // eslint-disable-next-line no-console\n\n\n    console.warn('Unknown state encountered for block', block);\n    tree.push(block);\n  }\n\n  return tree;\n}\n\nfunction isListBlock(block) {\n  return Boolean(block.listItem);\n}\n\nfunction blockMatchesList(block, list) {\n  return block.level === list.level && block.listItem === list.listItem;\n}\n\nfunction listFromBlock(block) {\n  return {\n    _type: 'list',\n    _key: \"\".concat(block._key, \"-parent\"),\n    level: block.level,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\n\nfunction lastChild(block) {\n  return block.children && block.children[block.children.length - 1];\n}\n\nfunction findListMatching(rootNode, matching) {\n  var filterOnType = typeof matching.listItem === 'string';\n\n  if (rootNode._type === 'list' && rootNode.level === matching.level && filterOnType && rootNode.listItem === matching.listItem) {\n    return rootNode;\n  }\n\n  var node = lastChild(rootNode);\n\n  if (!node) {\n    return false;\n  }\n\n  return findListMatching(node, matching);\n}\n\nmodule.exports = nestLists;","map":{"version":3,"sources":["../src/nestLists.js"],"names":["objectAssign","require","mode","tree","i","blocks","block","isListBlock","currentList","listFromBlock","blockMatchesList","newList","lastListItem","lastChild","newLastChild","children","match","findListMatching","level","console","Boolean","list","_type","_key","listItem","filterOnType","matching","rootNode","node","module"],"mappings":"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","sourcesContent":["const objectAssign = require('object-assign')\n\n/* eslint-disable max-depth, complexity */\nfunction nestLists(blocks, mode = 'html') {\n  const tree = []\n  let currentList\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!isListBlock(block)) {\n      tree.push(block)\n      currentList = null\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if (block.level > currentList.level) {\n      const newList = listFromBlock(block)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // We actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = lastChild(currentList)\n        const newLastChild = objectAssign({}, lastListItem, {\n          children: lastListItem.children.concat(newList)\n        })\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        currentList.children.push(newList)\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if (block.level < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const match = findListMatching(tree[tree.length - 1], block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const match = findListMatching(tree[tree.length - 1], {level: block.level})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction isListBlock(block) {\n  return Boolean(block.listItem)\n}\n\nfunction blockMatchesList(block, list) {\n  return block.level === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(block) {\n  return {\n    _type: 'list',\n    _key: `${block._key}-parent`,\n    level: block.level,\n    listItem: block.listItem,\n    children: [block]\n  }\n}\n\nfunction lastChild(block) {\n  return block.children && block.children[block.children.length - 1]\n}\n\nfunction findListMatching(rootNode, matching) {\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    rootNode._type === 'list' &&\n    rootNode.level === matching.level &&\n    (filterOnType && rootNode.listItem === matching.listItem)\n  ) {\n    return rootNode\n  }\n\n  const node = lastChild(rootNode)\n  if (!node) {\n    return false\n  }\n\n  return findListMatching(node, matching)\n}\n\nmodule.exports = nestLists\n"]},"metadata":{},"sourceType":"script"}