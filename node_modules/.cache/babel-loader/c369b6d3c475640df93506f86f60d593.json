{"ast":null,"code":"'use strict';\n\nvar pubsub = require('nano-pubsub');\n\nvar middlewareReducer = require('./util/middlewareReducer');\n\nvar processOptions = require('./middleware/defaultOptionsProcessor');\n\nvar validateOptions = require('./middleware/defaultOptionsValidator');\n\nvar httpRequest = require('./request'); // node-request in node, browser-request in browsers\n\n\nvar channelNames = ['request', 'response', 'progress', 'error', 'abort'];\nvar middlehooks = ['processOptions', 'validateOptions', 'interceptRequest', 'finalizeOptions', 'onRequest', 'onResponse', 'onError', 'onReturn', 'onHeaders'];\n\nmodule.exports = function createRequester() {\n  var initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var loadedMiddleware = [];\n  var middleware = middlehooks.reduce(function (ware, name) {\n    ware[name] = ware[name] || [];\n    return ware;\n  }, {\n    processOptions: [processOptions],\n    validateOptions: [validateOptions]\n  });\n\n  function request(opts) {\n    var channels = channelNames.reduce(function (target, name) {\n      target[name] = pubsub();\n      return target;\n    }, {}); // Prepare a middleware reducer that can be reused throughout the lifecycle\n\n    var applyMiddleware = middlewareReducer(middleware); // Parse the passed options\n\n    var options = applyMiddleware('processOptions', opts); // Validate the options\n\n    applyMiddleware('validateOptions', options); // Build a context object we can pass to child handlers\n\n    var context = {\n      options: options,\n      channels: channels,\n      applyMiddleware: applyMiddleware // We need to hold a reference to the current, ongoing request,\n      // in order to allow cancellation. In the case of the retry middleware,\n      // a new request might be triggered\n\n    };\n    var ongoingRequest = null;\n    var unsubscribe = channels.request.subscribe(function (ctx) {\n      // Let request adapters (node/browser) perform the actual request\n      ongoingRequest = httpRequest(ctx, function (err, res) {\n        return onResponse(err, res, ctx);\n      });\n    }); // If we abort the request, prevent further requests from happening,\n    // and be sure to cancel any ongoing request (obviously)\n\n    channels.abort.subscribe(function () {\n      unsubscribe();\n\n      if (ongoingRequest) {\n        ongoingRequest.abort();\n      }\n    }); // See if any middleware wants to modify the return value - for instance\n    // the promise or observable middlewares\n\n    var returnValue = applyMiddleware('onReturn', channels, context); // If return value has been modified by a middleware, we expect the middleware\n    // to publish on the 'request' channel. If it hasn't been modified, we want to\n    // trigger it right away\n\n    if (returnValue === channels) {\n      channels.request.publish(context);\n    }\n\n    return returnValue;\n\n    function onResponse(reqErr, res, ctx) {\n      var error = reqErr;\n      var response = res; // We're processing non-errors first, in case a middleware converts the\n      // response into an error (for instance, status >= 400 == HttpError)\n\n      if (!error) {\n        try {\n          response = applyMiddleware('onResponse', res, ctx);\n        } catch (err) {\n          response = null;\n          error = err;\n        }\n      } // Apply error middleware - if middleware return the same (or a different) error,\n      // publish as an error event. If we *don't* return an error, assume it has been handled\n\n\n      error = error && applyMiddleware('onError', error, ctx); // Figure out if we should publish on error/response channels\n\n      if (error) {\n        channels.error.publish(error);\n      } else if (response) {\n        channels.response.publish(response);\n      }\n    }\n  }\n\n  request.use = function use(newMiddleware) {\n    if (!newMiddleware) {\n      throw new Error('Tried to add middleware that resolved to falsey value');\n    }\n\n    if (typeof newMiddleware === 'function') {\n      throw new Error('Tried to add middleware that was a function. It probably expects you to pass options to it.');\n    }\n\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n      throw new Error('Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event');\n    }\n\n    middlehooks.forEach(function (key) {\n      if (newMiddleware[key]) {\n        middleware[key].push(newMiddleware[key]);\n      }\n    });\n    loadedMiddleware.push(newMiddleware);\n    return request;\n  };\n\n  request.clone = function clone() {\n    return createRequester(loadedMiddleware);\n  };\n\n  initMiddleware.forEach(request.use);\n  return request;\n};","map":{"version":3,"sources":["../src/index.js"],"names":["pubsub","require","middlewareReducer","processOptions","validateOptions","httpRequest","channelNames","middlehooks","module","initMiddleware","loadedMiddleware","middleware","ware","channels","target","applyMiddleware","options","context","ongoingRequest","unsubscribe","onResponse","returnValue","error","response","request","newMiddleware","createRequester"],"mappings":"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","sourcesContent":["const pubsub = require('nano-pubsub')\nconst middlewareReducer = require('./util/middlewareReducer')\nconst processOptions = require('./middleware/defaultOptionsProcessor')\nconst validateOptions = require('./middleware/defaultOptionsValidator')\nconst httpRequest = require('./request') // node-request in node, browser-request in browsers\n\nconst channelNames = ['request', 'response', 'progress', 'error', 'abort']\nconst middlehooks = [\n  'processOptions',\n  'validateOptions',\n  'interceptRequest',\n  'finalizeOptions',\n  'onRequest',\n  'onResponse',\n  'onError',\n  'onReturn',\n  'onHeaders'\n]\n\nmodule.exports = function createRequester(initMiddleware = []) {\n  const loadedMiddleware = []\n  const middleware = middlehooks.reduce(\n    (ware, name) => {\n      ware[name] = ware[name] || []\n      return ware\n    },\n    {\n      processOptions: [processOptions],\n      validateOptions: [validateOptions]\n    }\n  )\n\n  function request(opts) {\n    const channels = channelNames.reduce((target, name) => {\n      target[name] = pubsub()\n      return target\n    }, {})\n\n    // Prepare a middleware reducer that can be reused throughout the lifecycle\n    const applyMiddleware = middlewareReducer(middleware)\n\n    // Parse the passed options\n    const options = applyMiddleware('processOptions', opts)\n\n    // Validate the options\n    applyMiddleware('validateOptions', options)\n\n    // Build a context object we can pass to child handlers\n    const context = {options, channels, applyMiddleware}\n\n    // We need to hold a reference to the current, ongoing request,\n    // in order to allow cancellation. In the case of the retry middleware,\n    // a new request might be triggered\n    let ongoingRequest = null\n    const unsubscribe = channels.request.subscribe(ctx => {\n      // Let request adapters (node/browser) perform the actual request\n      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res, ctx))\n    })\n\n    // If we abort the request, prevent further requests from happening,\n    // and be sure to cancel any ongoing request (obviously)\n    channels.abort.subscribe(() => {\n      unsubscribe()\n      if (ongoingRequest) {\n        ongoingRequest.abort()\n      }\n    })\n\n    // See if any middleware wants to modify the return value - for instance\n    // the promise or observable middlewares\n    const returnValue = applyMiddleware('onReturn', channels, context)\n\n    // If return value has been modified by a middleware, we expect the middleware\n    // to publish on the 'request' channel. If it hasn't been modified, we want to\n    // trigger it right away\n    if (returnValue === channels) {\n      channels.request.publish(context)\n    }\n\n    return returnValue\n\n    function onResponse(reqErr, res, ctx) {\n      let error = reqErr\n      let response = res\n\n      // We're processing non-errors first, in case a middleware converts the\n      // response into an error (for instance, status >= 400 == HttpError)\n      if (!error) {\n        try {\n          response = applyMiddleware('onResponse', res, ctx)\n        } catch (err) {\n          response = null\n          error = err\n        }\n      }\n\n      // Apply error middleware - if middleware return the same (or a different) error,\n      // publish as an error event. If we *don't* return an error, assume it has been handled\n      error = error && applyMiddleware('onError', error, ctx)\n\n      // Figure out if we should publish on error/response channels\n      if (error) {\n        channels.error.publish(error)\n      } else if (response) {\n        channels.response.publish(response)\n      }\n    }\n  }\n\n  request.use = function use(newMiddleware) {\n    if (!newMiddleware) {\n      throw new Error('Tried to add middleware that resolved to falsey value')\n    }\n\n    if (typeof newMiddleware === 'function') {\n      throw new Error(\n        'Tried to add middleware that was a function. It probably expects you to pass options to it.'\n      )\n    }\n\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n      throw new Error(\n        'Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event'\n      )\n    }\n\n    middlehooks.forEach(key => {\n      if (newMiddleware[key]) {\n        middleware[key].push(newMiddleware[key])\n      }\n    })\n\n    loadedMiddleware.push(newMiddleware)\n    return request\n  }\n\n  request.clone = function clone() {\n    return createRequester(loadedMiddleware)\n  }\n\n  initMiddleware.forEach(request.use)\n\n  return request\n}\n"]},"metadata":{},"sourceType":"script"}