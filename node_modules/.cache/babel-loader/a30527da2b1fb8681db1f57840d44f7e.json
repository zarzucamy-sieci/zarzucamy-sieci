{"ast":null,"code":"\"use strict\";\n\nvar assign = require('object-assign');\n\nvar Observable = require('@sanity/observable/minimal');\n\nvar polyfilledEventSource = require('@sanity/eventsource');\n\nvar pick = require('../util/pick');\n\nvar defaults = require('../util/defaults');\n\nvar encodeQueryString = require('./encodeQueryString');\n\nvar generateHelpUrl = require('@sanity/generate-help-url');\n\nvar once = require('../util/once');\n\nvar tokenWarning = ['Using token with listeners is not supported in browsers. ', \"For more info, see \".concat(generateHelpUrl('js-client-listener-tokens-browser'), \".\")]; // eslint-disable-next-line no-console\n\nvar printTokenWarning = once(function () {\n  return console.warn(tokenWarning.join(' '));\n});\nvar isWindowEventSource = Boolean(typeof window !== 'undefined' && window.EventSource);\nvar EventSource = isWindowEventSource ? window.EventSource // Native browser EventSource\n: polyfilledEventSource; // Node.js, IE etc\n\nvar possibleOptions = ['includePreviousRevision', 'includeResult', 'visibility', 'effectFormat'];\nvar defaultOptions = {\n  includeResult: true\n};\n\nmodule.exports = function listen(query, params) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var options = defaults(opts, defaultOptions);\n  var listenOpts = pick(options, possibleOptions);\n  var qs = encodeQueryString({\n    query: query,\n    params: params,\n    options: listenOpts\n  });\n  var _this$clientConfig = this.clientConfig,\n      url = _this$clientConfig.url,\n      token = _this$clientConfig.token,\n      withCredentials = _this$clientConfig.withCredentials;\n  var uri = \"\".concat(url).concat(this.getDataUrl('listen', qs));\n  var listenFor = options.events ? options.events : ['mutation'];\n  var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;\n\n  if (token && isWindowEventSource) {\n    printTokenWarning();\n  }\n\n  var esOptions = {};\n\n  if (token || withCredentials) {\n    esOptions.withCredentials = true;\n  }\n\n  if (token) {\n    esOptions.headers = {\n      Authorization: \"Bearer \".concat(token)\n    };\n  }\n\n  return new Observable(function (observer) {\n    var es = getEventSource();\n    var reconnectTimer;\n    var stopped = false;\n\n    function onError() {\n      if (stopped) {\n        return;\n      }\n\n      emitReconnect(); // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt\n\n      if (stopped) {\n        return;\n      } // Unless we've explicitly stopped the ES (in which case `stopped` should be true),\n      // we should never be in a disconnected state. By default, EventSource will reconnect\n      // automatically, in which case it sets readyState to `CONNECTING`, but in some cases\n      // (like when a laptop lid is closed), it closes the connection. In these cases we need\n      // to explicitly reconnect.\n\n\n      if (es.readyState === EventSource.CLOSED) {\n        unsubscribe();\n        clearTimeout(reconnectTimer);\n        reconnectTimer = setTimeout(open, 100);\n      }\n    }\n\n    function onChannelError(err) {\n      observer.error(cooerceError(err));\n    }\n\n    function onMessage(evt) {\n      var event = parseEvent(evt);\n      return event instanceof Error ? observer.error(event) : observer.next(event);\n    }\n\n    function onDisconnect(evt) {\n      stopped = true;\n      unsubscribe();\n      observer.complete();\n    }\n\n    function unsubscribe() {\n      es.removeEventListener('error', onError, false);\n      es.removeEventListener('channelError', onChannelError, false);\n      es.removeEventListener('disconnect', onDisconnect, false);\n      listenFor.forEach(function (type) {\n        return es.removeEventListener(type, onMessage, false);\n      });\n      es.close();\n    }\n\n    function emitReconnect() {\n      if (shouldEmitReconnect) {\n        observer.next({\n          type: 'reconnect'\n        });\n      }\n    }\n\n    function getEventSource() {\n      var evs = new EventSource(uri, esOptions);\n      evs.addEventListener('error', onError, false);\n      evs.addEventListener('channelError', onChannelError, false);\n      evs.addEventListener('disconnect', onDisconnect, false);\n      listenFor.forEach(function (type) {\n        return evs.addEventListener(type, onMessage, false);\n      });\n      return evs;\n    }\n\n    function open() {\n      es = getEventSource();\n    }\n\n    function stop() {\n      stopped = true;\n      unsubscribe();\n    }\n\n    return stop;\n  });\n};\n\nfunction parseEvent(event) {\n  try {\n    var data = event.data && JSON.parse(event.data) || {};\n    return assign({\n      type: event.type\n    }, data);\n  } catch (err) {\n    return err;\n  }\n}\n\nfunction cooerceError(err) {\n  if (err instanceof Error) {\n    return err;\n  }\n\n  var evt = parseEvent(err);\n  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));\n}\n\nfunction extractErrorMessage(err) {\n  if (!err.error) {\n    return err.message || 'Unknown listener error';\n  }\n\n  if (err.error.description) {\n    return err.error.description;\n  }\n\n  return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2);\n}","map":{"version":3,"sources":["C:/Users/enthusiast/Documents/Informatyka/Projekty/Zarzucamy_Sieci_Blog/zarzucamy-sieci-blog/node_modules/@sanity/client/lib/data/listen.js"],"names":["assign","require","Observable","polyfilledEventSource","pick","defaults","encodeQueryString","generateHelpUrl","once","tokenWarning","concat","printTokenWarning","console","warn","join","isWindowEventSource","Boolean","window","EventSource","possibleOptions","defaultOptions","includeResult","module","exports","listen","query","params","opts","arguments","length","undefined","options","listenOpts","qs","_this$clientConfig","clientConfig","url","token","withCredentials","uri","getDataUrl","listenFor","events","shouldEmitReconnect","indexOf","esOptions","headers","Authorization","observer","es","getEventSource","reconnectTimer","stopped","onError","emitReconnect","readyState","CLOSED","unsubscribe","clearTimeout","setTimeout","open","onChannelError","err","error","cooerceError","onMessage","evt","event","parseEvent","Error","next","onDisconnect","complete","removeEventListener","forEach","type","close","evs","addEventListener","stop","data","JSON","parse","extractErrorMessage","message","description","stringify"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,eAAD,CAApB;;AAEA,IAAIC,UAAU,GAAGD,OAAO,CAAC,4BAAD,CAAxB;;AAEA,IAAIE,qBAAqB,GAAGF,OAAO,CAAC,qBAAD,CAAnC;;AAEA,IAAIG,IAAI,GAAGH,OAAO,CAAC,cAAD,CAAlB;;AAEA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,kBAAD,CAAtB;;AAEA,IAAIK,iBAAiB,GAAGL,OAAO,CAAC,qBAAD,CAA/B;;AAEA,IAAIM,eAAe,GAAGN,OAAO,CAAC,2BAAD,CAA7B;;AAEA,IAAIO,IAAI,GAAGP,OAAO,CAAC,cAAD,CAAlB;;AAEA,IAAIQ,YAAY,GAAG,CAAC,2DAAD,EAA8D,sBAAsBC,MAAtB,CAA6BH,eAAe,CAAC,mCAAD,CAA5C,EAAmF,GAAnF,CAA9D,CAAnB,C,CAA2K;;AAE3K,IAAII,iBAAiB,GAAGH,IAAI,CAAC,YAAY;AACvC,SAAOI,OAAO,CAACC,IAAR,CAAaJ,YAAY,CAACK,IAAb,CAAkB,GAAlB,CAAb,CAAP;AACD,CAF2B,CAA5B;AAGA,IAAIC,mBAAmB,GAAGC,OAAO,CAAC,OAAOC,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,WAAzC,CAAjC;AACA,IAAIA,WAAW,GAAGH,mBAAmB,GAAGE,MAAM,CAACC,WAAV,CAAsB;AAAtB,EACnCf,qBADF,C,CACyB;;AAEzB,IAAIgB,eAAe,GAAG,CAAC,yBAAD,EAA4B,eAA5B,EAA6C,YAA7C,EAA2D,cAA3D,CAAtB;AACA,IAAIC,cAAc,GAAG;AACnBC,EAAAA,aAAa,EAAE;AADI,CAArB;;AAIAC,MAAM,CAACC,OAAP,GAAiB,SAASC,MAAT,CAAgBC,KAAhB,EAAuBC,MAAvB,EAA+B;AAC9C,MAAIC,IAAI,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/E;AACA,MAAIG,OAAO,GAAG1B,QAAQ,CAACsB,IAAD,EAAOP,cAAP,CAAtB;AACA,MAAIY,UAAU,GAAG5B,IAAI,CAAC2B,OAAD,EAAUZ,eAAV,CAArB;AACA,MAAIc,EAAE,GAAG3B,iBAAiB,CAAC;AACzBmB,IAAAA,KAAK,EAAEA,KADkB;AAEzBC,IAAAA,MAAM,EAAEA,MAFiB;AAGzBK,IAAAA,OAAO,EAAEC;AAHgB,GAAD,CAA1B;AAKA,MAAIE,kBAAkB,GAAG,KAAKC,YAA9B;AAAA,MACIC,GAAG,GAAGF,kBAAkB,CAACE,GAD7B;AAAA,MAEIC,KAAK,GAAGH,kBAAkB,CAACG,KAF/B;AAAA,MAGIC,eAAe,GAAGJ,kBAAkB,CAACI,eAHzC;AAIA,MAAIC,GAAG,GAAG,GAAG7B,MAAH,CAAU0B,GAAV,EAAe1B,MAAf,CAAsB,KAAK8B,UAAL,CAAgB,QAAhB,EAA0BP,EAA1B,CAAtB,CAAV;AACA,MAAIQ,SAAS,GAAGV,OAAO,CAACW,MAAR,GAAiBX,OAAO,CAACW,MAAzB,GAAkC,CAAC,UAAD,CAAlD;AACA,MAAIC,mBAAmB,GAAGF,SAAS,CAACG,OAAV,CAAkB,WAAlB,MAAmC,CAAC,CAA9D;;AAEA,MAAIP,KAAK,IAAItB,mBAAb,EAAkC;AAChCJ,IAAAA,iBAAiB;AAClB;;AAED,MAAIkC,SAAS,GAAG,EAAhB;;AAEA,MAAIR,KAAK,IAAIC,eAAb,EAA8B;AAC5BO,IAAAA,SAAS,CAACP,eAAV,GAA4B,IAA5B;AACD;;AAED,MAAID,KAAJ,EAAW;AACTQ,IAAAA,SAAS,CAACC,OAAV,GAAoB;AAClBC,MAAAA,aAAa,EAAE,UAAUrC,MAAV,CAAiB2B,KAAjB;AADG,KAApB;AAGD;;AAED,SAAO,IAAInC,UAAJ,CAAe,UAAU8C,QAAV,EAAoB;AACxC,QAAIC,EAAE,GAAGC,cAAc,EAAvB;AACA,QAAIC,cAAJ;AACA,QAAIC,OAAO,GAAG,KAAd;;AAEA,aAASC,OAAT,GAAmB;AACjB,UAAID,OAAJ,EAAa;AACX;AACD;;AAEDE,MAAAA,aAAa,GALI,CAKA;;AAEjB,UAAIF,OAAJ,EAAa;AACX;AACD,OATgB,CASf;AACF;AACA;AACA;AACA;;;AAGA,UAAIH,EAAE,CAACM,UAAH,KAAkBrC,WAAW,CAACsC,MAAlC,EAA0C;AACxCC,QAAAA,WAAW;AACXC,QAAAA,YAAY,CAACP,cAAD,CAAZ;AACAA,QAAAA,cAAc,GAAGQ,UAAU,CAACC,IAAD,EAAO,GAAP,CAA3B;AACD;AACF;;AAED,aAASC,cAAT,CAAwBC,GAAxB,EAA6B;AAC3Bd,MAAAA,QAAQ,CAACe,KAAT,CAAeC,YAAY,CAACF,GAAD,CAA3B;AACD;;AAED,aAASG,SAAT,CAAmBC,GAAnB,EAAwB;AACtB,UAAIC,KAAK,GAAGC,UAAU,CAACF,GAAD,CAAtB;AACA,aAAOC,KAAK,YAAYE,KAAjB,GAAyBrB,QAAQ,CAACe,KAAT,CAAeI,KAAf,CAAzB,GAAiDnB,QAAQ,CAACsB,IAAT,CAAcH,KAAd,CAAxD;AACD;;AAED,aAASI,YAAT,CAAsBL,GAAtB,EAA2B;AACzBd,MAAAA,OAAO,GAAG,IAAV;AACAK,MAAAA,WAAW;AACXT,MAAAA,QAAQ,CAACwB,QAAT;AACD;;AAED,aAASf,WAAT,GAAuB;AACrBR,MAAAA,EAAE,CAACwB,mBAAH,CAAuB,OAAvB,EAAgCpB,OAAhC,EAAyC,KAAzC;AACAJ,MAAAA,EAAE,CAACwB,mBAAH,CAAuB,cAAvB,EAAuCZ,cAAvC,EAAuD,KAAvD;AACAZ,MAAAA,EAAE,CAACwB,mBAAH,CAAuB,YAAvB,EAAqCF,YAArC,EAAmD,KAAnD;AACA9B,MAAAA,SAAS,CAACiC,OAAV,CAAkB,UAAUC,IAAV,EAAgB;AAChC,eAAO1B,EAAE,CAACwB,mBAAH,CAAuBE,IAAvB,EAA6BV,SAA7B,EAAwC,KAAxC,CAAP;AACD,OAFD;AAGAhB,MAAAA,EAAE,CAAC2B,KAAH;AACD;;AAED,aAAStB,aAAT,GAAyB;AACvB,UAAIX,mBAAJ,EAAyB;AACvBK,QAAAA,QAAQ,CAACsB,IAAT,CAAc;AACZK,UAAAA,IAAI,EAAE;AADM,SAAd;AAGD;AACF;;AAED,aAASzB,cAAT,GAA0B;AACxB,UAAI2B,GAAG,GAAG,IAAI3D,WAAJ,CAAgBqB,GAAhB,EAAqBM,SAArB,CAAV;AACAgC,MAAAA,GAAG,CAACC,gBAAJ,CAAqB,OAArB,EAA8BzB,OAA9B,EAAuC,KAAvC;AACAwB,MAAAA,GAAG,CAACC,gBAAJ,CAAqB,cAArB,EAAqCjB,cAArC,EAAqD,KAArD;AACAgB,MAAAA,GAAG,CAACC,gBAAJ,CAAqB,YAArB,EAAmCP,YAAnC,EAAiD,KAAjD;AACA9B,MAAAA,SAAS,CAACiC,OAAV,CAAkB,UAAUC,IAAV,EAAgB;AAChC,eAAOE,GAAG,CAACC,gBAAJ,CAAqBH,IAArB,EAA2BV,SAA3B,EAAsC,KAAtC,CAAP;AACD,OAFD;AAGA,aAAOY,GAAP;AACD;;AAED,aAASjB,IAAT,GAAgB;AACdX,MAAAA,EAAE,GAAGC,cAAc,EAAnB;AACD;;AAED,aAAS6B,IAAT,GAAgB;AACd3B,MAAAA,OAAO,GAAG,IAAV;AACAK,MAAAA,WAAW;AACZ;;AAED,WAAOsB,IAAP;AACD,GAlFM,CAAP;AAmFD,CApHD;;AAsHA,SAASX,UAAT,CAAoBD,KAApB,EAA2B;AACzB,MAAI;AACF,QAAIa,IAAI,GAAGb,KAAK,CAACa,IAAN,IAAcC,IAAI,CAACC,KAAL,CAAWf,KAAK,CAACa,IAAjB,CAAd,IAAwC,EAAnD;AACA,WAAOhF,MAAM,CAAC;AACZ2E,MAAAA,IAAI,EAAER,KAAK,CAACQ;AADA,KAAD,EAEVK,IAFU,CAAb;AAGD,GALD,CAKE,OAAOlB,GAAP,EAAY;AACZ,WAAOA,GAAP;AACD;AACF;;AAED,SAASE,YAAT,CAAsBF,GAAtB,EAA2B;AACzB,MAAIA,GAAG,YAAYO,KAAnB,EAA0B;AACxB,WAAOP,GAAP;AACD;;AAED,MAAII,GAAG,GAAGE,UAAU,CAACN,GAAD,CAApB;AACA,SAAOI,GAAG,YAAYG,KAAf,GAAuBH,GAAvB,GAA6B,IAAIG,KAAJ,CAAUc,mBAAmB,CAACjB,GAAD,CAA7B,CAApC;AACD;;AAED,SAASiB,mBAAT,CAA6BrB,GAA7B,EAAkC;AAChC,MAAI,CAACA,GAAG,CAACC,KAAT,EAAgB;AACd,WAAOD,GAAG,CAACsB,OAAJ,IAAe,wBAAtB;AACD;;AAED,MAAItB,GAAG,CAACC,KAAJ,CAAUsB,WAAd,EAA2B;AACzB,WAAOvB,GAAG,CAACC,KAAJ,CAAUsB,WAAjB;AACD;;AAED,SAAO,OAAOvB,GAAG,CAACC,KAAX,KAAqB,QAArB,GAAgCD,GAAG,CAACC,KAApC,GAA4CkB,IAAI,CAACK,SAAL,CAAexB,GAAG,CAACC,KAAnB,EAA0B,IAA1B,EAAgC,CAAhC,CAAnD;AACD","sourcesContent":["\"use strict\";\n\nvar assign = require('object-assign');\n\nvar Observable = require('@sanity/observable/minimal');\n\nvar polyfilledEventSource = require('@sanity/eventsource');\n\nvar pick = require('../util/pick');\n\nvar defaults = require('../util/defaults');\n\nvar encodeQueryString = require('./encodeQueryString');\n\nvar generateHelpUrl = require('@sanity/generate-help-url');\n\nvar once = require('../util/once');\n\nvar tokenWarning = ['Using token with listeners is not supported in browsers. ', \"For more info, see \".concat(generateHelpUrl('js-client-listener-tokens-browser'), \".\")]; // eslint-disable-next-line no-console\n\nvar printTokenWarning = once(function () {\n  return console.warn(tokenWarning.join(' '));\n});\nvar isWindowEventSource = Boolean(typeof window !== 'undefined' && window.EventSource);\nvar EventSource = isWindowEventSource ? window.EventSource // Native browser EventSource\n: polyfilledEventSource; // Node.js, IE etc\n\nvar possibleOptions = ['includePreviousRevision', 'includeResult', 'visibility', 'effectFormat'];\nvar defaultOptions = {\n  includeResult: true\n};\n\nmodule.exports = function listen(query, params) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var options = defaults(opts, defaultOptions);\n  var listenOpts = pick(options, possibleOptions);\n  var qs = encodeQueryString({\n    query: query,\n    params: params,\n    options: listenOpts\n  });\n  var _this$clientConfig = this.clientConfig,\n      url = _this$clientConfig.url,\n      token = _this$clientConfig.token,\n      withCredentials = _this$clientConfig.withCredentials;\n  var uri = \"\".concat(url).concat(this.getDataUrl('listen', qs));\n  var listenFor = options.events ? options.events : ['mutation'];\n  var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;\n\n  if (token && isWindowEventSource) {\n    printTokenWarning();\n  }\n\n  var esOptions = {};\n\n  if (token || withCredentials) {\n    esOptions.withCredentials = true;\n  }\n\n  if (token) {\n    esOptions.headers = {\n      Authorization: \"Bearer \".concat(token)\n    };\n  }\n\n  return new Observable(function (observer) {\n    var es = getEventSource();\n    var reconnectTimer;\n    var stopped = false;\n\n    function onError() {\n      if (stopped) {\n        return;\n      }\n\n      emitReconnect(); // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt\n\n      if (stopped) {\n        return;\n      } // Unless we've explicitly stopped the ES (in which case `stopped` should be true),\n      // we should never be in a disconnected state. By default, EventSource will reconnect\n      // automatically, in which case it sets readyState to `CONNECTING`, but in some cases\n      // (like when a laptop lid is closed), it closes the connection. In these cases we need\n      // to explicitly reconnect.\n\n\n      if (es.readyState === EventSource.CLOSED) {\n        unsubscribe();\n        clearTimeout(reconnectTimer);\n        reconnectTimer = setTimeout(open, 100);\n      }\n    }\n\n    function onChannelError(err) {\n      observer.error(cooerceError(err));\n    }\n\n    function onMessage(evt) {\n      var event = parseEvent(evt);\n      return event instanceof Error ? observer.error(event) : observer.next(event);\n    }\n\n    function onDisconnect(evt) {\n      stopped = true;\n      unsubscribe();\n      observer.complete();\n    }\n\n    function unsubscribe() {\n      es.removeEventListener('error', onError, false);\n      es.removeEventListener('channelError', onChannelError, false);\n      es.removeEventListener('disconnect', onDisconnect, false);\n      listenFor.forEach(function (type) {\n        return es.removeEventListener(type, onMessage, false);\n      });\n      es.close();\n    }\n\n    function emitReconnect() {\n      if (shouldEmitReconnect) {\n        observer.next({\n          type: 'reconnect'\n        });\n      }\n    }\n\n    function getEventSource() {\n      var evs = new EventSource(uri, esOptions);\n      evs.addEventListener('error', onError, false);\n      evs.addEventListener('channelError', onChannelError, false);\n      evs.addEventListener('disconnect', onDisconnect, false);\n      listenFor.forEach(function (type) {\n        return evs.addEventListener(type, onMessage, false);\n      });\n      return evs;\n    }\n\n    function open() {\n      es = getEventSource();\n    }\n\n    function stop() {\n      stopped = true;\n      unsubscribe();\n    }\n\n    return stop;\n  });\n};\n\nfunction parseEvent(event) {\n  try {\n    var data = event.data && JSON.parse(event.data) || {};\n    return assign({\n      type: event.type\n    }, data);\n  } catch (err) {\n    return err;\n  }\n}\n\nfunction cooerceError(err) {\n  if (err instanceof Error) {\n    return err;\n  }\n\n  var evt = parseEvent(err);\n  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));\n}\n\nfunction extractErrorMessage(err) {\n  if (!err.error) {\n    return err.message || 'Unknown listener error';\n  }\n\n  if (err.error.description) {\n    return err.error.description;\n  }\n\n  return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2);\n}"]},"metadata":{},"sourceType":"script"}