{"ast":null,"code":"\"use strict\";\n\nvar defaultMarks = ['strong', 'em', 'code', 'underline', 'strike-through'];\n\nvar buildMarksTree = function buildMarksTree(block) {\n  var children = block.children,\n      markDefs = block.markDefs;\n\n  if (!children || !children.length) {\n    return [];\n  }\n\n  var sortedMarks = children.map(sortMarksByOccurences);\n  var rootNode = {\n    _type: 'span',\n    children: []\n  };\n  var nodeStack = [rootNode];\n  children.forEach(function (span, i) {\n    var marksNeeded = sortedMarks[i];\n\n    if (!marksNeeded) {\n      var lastNode = nodeStack[nodeStack.length - 1];\n      lastNode.children.push(span);\n      return;\n    }\n\n    var pos = 1; // Start at position one. Root is always plain and should never be removed. (?)\n\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        var mark = nodeStack[pos].markKey;\n        var index = marksNeeded.indexOf(mark); // eslint-disable-next-line max-depth\n\n        if (index === -1) {\n          break;\n        }\n\n        marksNeeded.splice(index, 1);\n      }\n    } // Keep from beginning to first miss\n\n\n    nodeStack = nodeStack.slice(0, pos); // Add needed nodes\n\n    var currentNode = findLastParentNode(nodeStack);\n    marksNeeded.forEach(function (mark) {\n      var node = {\n        _type: 'span',\n        _key: span._key,\n        children: [],\n        mark: markDefs.find(function (def) {\n          return def._key === mark;\n        }) || mark,\n        markKey: mark\n      };\n      currentNode.children.push(node);\n      nodeStack.push(node);\n      currentNode = node;\n    }); // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n\n    if (isTextSpan(span)) {\n      var lines = span.text.split('\\n');\n\n      for (var line = lines.length; line-- > 1;) {\n        lines.splice(line, 0, '\\n');\n      }\n\n      currentNode.children = currentNode.children.concat(lines);\n    } else {\n      currentNode.children = currentNode.children.concat(span);\n    }\n  });\n  return rootNode.children;\n}; // We want to sort all the marks of all the spans in the following order:\n// 1. Marks that are shared amongst the most adjacent siblings\n// 2. Non-default marks (links, custom metadata)\n// 3. Built-in, plain marks (bold, emphasis, code etc)\n\n\nfunction sortMarksByOccurences(span, i, spans) {\n  if (!span.marks || span.marks.length === 0) {\n    return span.marks || [];\n  }\n\n  var markOccurences = span.marks.reduce(function (occurences, mark) {\n    occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1;\n\n    for (var siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {\n      var sibling = spans[siblingIndex];\n\n      if (sibling.marks && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n        occurences[mark]++;\n      } else {\n        break;\n      }\n    }\n\n    return occurences;\n  }, {});\n  var sortByOccurence = sortMarks.bind(null, markOccurences); // Slicing because sort() mutates the input\n\n  return span.marks.slice().sort(sortByOccurence);\n}\n\nfunction sortMarks(occurences, markA, markB) {\n  var aOccurences = occurences[markA] || 0;\n  var bOccurences = occurences[markB] || 0;\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences;\n  }\n\n  var aDefaultPos = defaultMarks.indexOf(markA);\n  var bDefaultPos = defaultMarks.indexOf(markB); // Sort default marks last\n\n  if (aDefaultPos !== bDefaultPos) {\n    return aDefaultPos - bDefaultPos;\n  } // Sort other marks simply by key\n\n\n  if (markA < markB) {\n    return -1;\n  } else if (markA > markB) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction isTextSpan(node) {\n  return node._type === 'span' && typeof node.text === 'string' && (Array.isArray(node.marks) || typeof node.marks === 'undefined');\n}\n\nfunction findLastParentNode(nodes) {\n  for (var i = nodes.length - 1; i >= 0; i--) {\n    var node = nodes[i];\n\n    if (node._type === 'span' && node.children) {\n      return node;\n    }\n  }\n\n  return undefined;\n}\n\nmodule.exports = buildMarksTree;","map":{"version":3,"sources":["../src/buildMarksTree.js"],"names":["defaultMarks","buildMarksTree","children","markDefs","block","sortedMarks","rootNode","_type","nodeStack","marksNeeded","lastNode","pos","mark","index","currentNode","findLastParentNode","node","_key","span","def","markKey","isTextSpan","lines","line","markOccurences","occurences","siblingIndex","i","spans","sibling","Array","sortByOccurence","sortMarks","aOccurences","bOccurences","aDefaultPos","bDefaultPos","markA","nodes","module"],"mappings":"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","sourcesContent":["const defaultMarks = ['strong', 'em', 'code', 'underline', 'strike-through']\n\nconst buildMarksTree = block => {\n  const {children, markDefs} = block\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n  const rootNode = {_type: 'span', children: []}\n  let nodeStack = [rootNode]\n\n  children.forEach((span, i) => {\n    const marksNeeded = sortedMarks[i]\n    if (!marksNeeded) {\n      const lastNode = nodeStack[nodeStack.length - 1]\n      lastNode.children.push(span)\n      return\n    }\n\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed. (?)\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos].markKey\n        const index = marksNeeded.indexOf(mark)\n        // eslint-disable-next-line max-depth\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = findLastParentNode(nodeStack)\n    marksNeeded.forEach(mark => {\n      const node = {\n        _type: 'span',\n        _key: span._key,\n        children: [],\n        mark: markDefs.find(def => def._key === mark) || mark,\n        markKey: mark\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    })\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(lines)\n    } else {\n      currentNode.children = currentNode.children.concat(span)\n    }\n  })\n\n  return rootNode.children\n}\n\n// We want to sort all the marks of all the spans in the following order:\n// 1. Marks that are shared amongst the most adjacent siblings\n// 2. Non-default marks (links, custom metadata)\n// 3. Built-in, plain marks (bold, emphasis, code etc)\nfunction sortMarksByOccurences(span, i, spans) {\n  if (!span.marks || span.marks.length === 0) {\n    return span.marks || []\n  }\n\n  const markOccurences = span.marks.reduce((occurences, mark) => {\n    occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1\n\n    for (let siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {\n      const sibling = spans[siblingIndex]\n\n      if (sibling.marks && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n\n    return occurences\n  }, {})\n\n  const sortByOccurence = sortMarks.bind(null, markOccurences)\n\n  // Slicing because sort() mutates the input\n  return span.marks.slice().sort(sortByOccurence)\n}\n\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA] || 0\n  const bOccurences = occurences[markB] || 0\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aDefaultPos = defaultMarks.indexOf(markA)\n  const bDefaultPos = defaultMarks.indexOf(markB)\n\n  // Sort default marks last\n  if (aDefaultPos !== bDefaultPos) {\n    return aDefaultPos - bDefaultPos\n  }\n\n  // Sort other marks simply by key\n  if (markA < markB) {\n    return -1\n  } else if (markA > markB) {\n    return 1\n  }\n\n  return 0\n}\n\nfunction isTextSpan(node) {\n  return (\n    node._type === 'span' &&\n    typeof node.text === 'string' &&\n    (Array.isArray(node.marks) || typeof node.marks === 'undefined')\n  )\n}\n\nfunction findLastParentNode(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const node = nodes[i]\n    if (node._type === 'span' && node.children) {\n      return node\n    }\n  }\n\n  return undefined\n}\n\nmodule.exports = buildMarksTree\n"]},"metadata":{},"sourceType":"script"}